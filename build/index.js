// Generated by LiveScript 1.3.1
var async, idDebug, idType, path, preludeLs, moment, debug, info, warning, error, each, keys, fold1, defaultOptions, logging, parseOptions, tasks, logInfo, runTaskWithOptions;
async = require('async');
idDebug = require('id-debug');
idType = require('id-type');
path = require('path');
preludeLs = require('prelude-ls');
moment = require('moment');
debug = idDebug.debug, info = idDebug.info, warning = idDebug.warning, error = idDebug.error;
each = preludeLs.each, keys = preludeLs.keys, fold1 = preludeLs.fold1;
defaultOptions = require("./lib/default-options");
logging = require("./lib/logging");
parseOptions = require("./lib/parse-options");
tasks = require("./tasks");
logInfo = function(message){
  return info(moment().format() + " " + message);
};
runTaskWithOptions = curry$(function(options, task, name, cb){
  var taskOptions;
  taskOptions = options != null ? options.tasks[name] : void 8;
  if (!taskOptions) {
    return cb("No options found for task `" + taskOptions + "`.");
  }
  taskOptions.taskName = name;
  taskOptions.longestTaskNameLength = fold1(function(m, x){
    return m.length > x.length && m || x;
  }, keys(tasks));
  logging.startTask(name);
  task.run(taskOptions, function(error){
    if (error) {
      return cb(error);
    }
    logging.finishTask(name);
    cb();
  });
});
module.exports = function(inputOptions, cb){
  var options, autoTasks, i$, ref$;
  inputOptions == null && (inputOptions = {});
  options = parseOptions(defaultOptions, inputOptions);
  autoTasks = {};
  for (i$ in ref$ = tasks) {
    (fn$.call(this, i$, ref$[i$]));
  }
  return async.auto(autoTasks, function(error, results){
    if (error) {
      return cb(error);
    }
  });
  function fn$(k, v){
    autoTasks[k] = v.dependencies.concat(runTaskWithOptions(options, v, k));
  }
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}