// Generated by LiveScript 1.3.1
var async, chokidar, fs, idDebug, path, preludeLs, debug, info, warning, each, filter, map, p, compileBrowserify, compileCoffeescript, compileJade, compileLess, compileLivescript, compileStylus, copy, documentation, runServers, runTests, updateFile, handleAdd, handleAddDir, handleChange, handleUnlink, handleUnlinkDir, handleError, slice$ = [].slice;
async = require('async');
chokidar = require('chokidar');
fs = require('fs');
idDebug = require('id-debug');
path = require('path');
preludeLs = require('prelude-ls');
debug = idDebug.debug, info = idDebug.info, warning = idDebug.warning;
each = preludeLs.each, filter = preludeLs.filter, map = preludeLs.map;
p = path;
compileBrowserify = require("./compile-browserify");
compileCoffeescript = require("./compile-coffeescript");
compileJade = require("./compile-jade");
compileLess = require("./compile-less");
compileLivescript = require("./compile-livescript");
compileStylus = require("./compile-stylus");
copy = require("./copy");
documentation = require("./documentation");
runServers = require("./run-servers");
runTests = require("./run-tests");
updateFile = curry$(function(options, task, path, stat){
  var targetPath;
  if (compileBrowserify.sourceFilePathMatches(options, options.tasks.compileBrowserify, path)) {
    compileBrowserify.compileFile(options, task, function(error){
      if (error) {
        idDebug.error(error);
      }
    });
  } else if (compileCoffeescript.sourceFilePathMatches(options, options.tasks.compileCoffeescript, path)) {
    targetPath = path.replace(options.tasks.compileCoffeescript.sourcePath, options.tasks.compileCoffeescript.targetPath).replace(RegExp('\\.' + compileCoffeescript.sourceExtension + '$'), "." + compileCoffeescript.targetExtension);
    compileBrowserify.compileFile(options, task, path, targetPath, function(error){
      if (error) {
        idDebug.error(error);
      }
    });
  } else if (compileJade.sourceFilePathMatches(options, options.tasks.compileJade, path)) {
    targetPath = path.replace(options.tasks.compileJade.sourcePath, options.tasks.compileJade.targetPath).replace(RegExp('\\.' + compileJade.sourceExtension + '$'), "." + compileJade.targetExtension);
    compileJade.compileFile(options, task, path, targetPath, function(error){
      if (error) {
        idDebug.error(error);
      }
    });
  } else if (compileLess.sourceFilePathMatches(options, options.tasks.compileLess, path)) {
    targetPath = path.replace(options.tasks.compileLess.sourcePath, options.tasks.compileLess.targetPath).replace(RegExp('\\.' + compileLess.sourceExtension + '$'), "." + compileLess.targetExtension);
    compileLess.compileFile(options, task, path, targetPath, function(error){
      if (error) {
        idDebug.error(error);
      }
    });
  } else if (compileLivescript.sourceFilePathMatches(options, options.tasks.compileLivescript, path)) {
    targetPath = path.replace(options.tasks.compileLivescript.sourcePath, options.tasks.compileLivescript.targetPath).replace(RegExp('\\.' + compileLivescript.sourceExtension + '$'), "." + compileLivescript.targetExtension);
    compileLivescript.compileFile(options, task, path, targetPath, function(error){
      if (error) {
        idDebug.error(error);
      }
    });
  } else if (compileStylus.sourceFilePathMatches(options, options.tasks.compileStylus, path)) {
    targetPath = path.replace(options.tasks.compileStylus.sourcePath, options.tasks.compileStylus.targetPath).replace(RegExp('\\.' + compileStylus.sourceExtension + '$'), "." + compileStylus.targetExtension);
    compileStylus.compileFile(options, task, path, targetPath, function(error){
      if (error) {
        idDebug.error(error);
      }
    });
  } else if (copy.sourceFilePathMatches(options, options.tasks.copy, path)) {
    targetPath = path.replace(options.tasks.copy.sourcePath, options.tasks.copy.targetPath);
    copy.copyFile(options, task, path, targetPath, function(error){
      if (error) {
        idDebug.error(error);
      }
    });
  } else if (documentation.sourceFilePathMatches(options, options.tasks.documentation, path)) {
    documentation.compileFile(options, task, function(error){
      if (error) {
        idDebug.error(error);
      }
    });
  } else if (runServers.sourceFilePathMatches(options, options.tasks.runServers, path)) {
    runServers.restartServers(options, task, function(error){
      if (error) {
        idDebug.error(error);
      }
    });
  } else if (runTests.sourceFilePathMatches(options, options.tasks.runTests, path)) {
    runTests.compileFile(options, task, function(error){
      if (error) {
        idDebug.error(error);
      }
    });
  }
});
handleAdd = curry$(function(options, task, path, stat){
  updateFile(options, task, p.resolve(path), stat);
});
handleAddDir = curry$(function(options, task, path, stat){
  debug("handle-add-dir", arguments);
});
handleChange = curry$(function(options, task, path, stat){
  updateFile(options, task, p.resolve(path), stat);
});
handleUnlink = curry$(function(options, task, path, stat){
  debug("handle-unlink", arguments);
});
handleUnlinkDir = curry$(function(options, task, path, stat){
  debug("handle-unlink-dir", arguments);
});
handleError = curry$(function(options, task, error){
  console.error(error);
});
module.exports = function(options, task){
  var watcher, i$, ref$, len$, i;
  if (!task.paths.length) {
    return;
  }
  watcher = chokidar.watch(task.paths[0], {
    ignored: /[\/\/]\./,
    persistent: true
  });
  watcher.on("ready", function(){
    watcher.on("add", handleAdd(options, task));
    watcher.on("addDir", handleAddDir(options, task));
    watcher.on("change", handleChange(options, task));
    watcher.on("unlink", handleUnlink(options, task));
    watcher.on("unlinkDir", handleUnlinkDir(options, task));
    return watcher.on("error", handleError(options, task));
  });
  for (i$ = 0, len$ = (ref$ = [1].concat(slice$.call(task.paths.length))).length; i$ < len$; ++i$) {
    i = ref$[i$];
    watcher.add(task.paths[i]);
  }
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}