// Generated by LiveScript 1.3.1
var async, browserify, fs, idDebug, path, watchify, p, debug, error, info, warning, fileSystem, logging, sourceExtension, targetExtension, globalOptions, pathReloads, sourceFilePathMatches, compileAllFiles, watch, out$ = typeof exports != 'undefined' && exports || this;
async = require('async');
browserify = require('browserify');
fs = require('fs');
idDebug = require('id-debug');
path = require('path');
watchify = require('watchify');
p = path;
debug = idDebug.debug, error = idDebug.error, info = idDebug.info, warning = idDebug.warning;
fileSystem = require("./file-system");
logging = require("./logging");
out$.sourceExtension = sourceExtension = "coffee";
out$.targetExtension = targetExtension = "js";
globalOptions = global.options;
out$.pathReloads = pathReloads = curry$(function(options, path){
  return path === globalOptions.tasks.watchBrowserify.targetPath;
});
out$.sourceFilePathMatches = sourceFilePathMatches = curry$(function(options, sourceFilePath){
  var resolvedSourceFilePath, resolvedSourceDirectoryPath;
  if (p.resolve(sourceFilePath) === p.resolve(options.targetPath)) {
    return;
  }
  resolvedSourceFilePath = p.resolve(sourceFilePath);
  resolvedSourceDirectoryPath = p.resolve(options.sourceDirectory);
  return resolvedSourceFilePath.indexOf(resolvedSourceDirectoryPath) === 0;
});
out$.compileAllFiles = compileAllFiles = function(options, cb){
  fs.exists(options.sourcePath, function(exists){
    if (!exists) {
      logging.taskInfo(options.taskName, "skipping `" + options.sourcePath + "` (Does not exist)");
      return cb();
    }
    fileSystem.ensureFileDirectory(options.targetPath, function(error){
      var b;
      if (error) {
        return cb(error);
      }
      b = browserify({
        cache: {},
        debug: true,
        fullPaths: true,
        packageCache: {}
      });
      b.transform("reactify");
      b.add(path.resolve(options.sourcePath));
      b.on("bundle", function(bundleStream){
        var writeStream;
        writeStream = fs.createWriteStream(options.targetPath);
        writeStream.on("error", function(error){
          cb(error);
        });
        writeStream.on("finish", function(){
          logging.taskInfo(options.taskName, "`" + options.sourcePath + "` => `" + options.targetPath + "`");
          cb();
        });
        return bundleStream.pipe(writeStream);
      });
      b.bundle();
    });
  });
};
out$.watch = watch = function(options, cb){
  var b, w;
  cb();
  b = browserify({
    cache: {},
    debug: true,
    fullPaths: true,
    packageCache: {}
  });
  b.transform("reactify");
  b.add(path.resolve(options.sourcePath));
  b.on("bundle", function(bundleStream){
    var data;
    data = "";
    bundleStream.on("data", function(d){
      data = data + "" + d.toString();
    });
    return bundleStream.on("end", function(){
      fs.writeFile(options.targetPath, data, function(e){
        if (e) {
          return error(e);
        }
        logging.taskInfo(options.taskName, "`" + options.sourcePath + "` => `" + options.targetPath + "`");
      });
    });
  });
  w = watchify(b);
  w.on("update", function(){
    b.bundle();
  });
  b.bundle();
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}