// Generated by LiveScript 1.3.1
var async, browserify, fs, path, watchify, fileSystem, logging, sourceExtension, targetExtension, globalOptions, pathReloads, sourceFilePathMatches, compileAllFiles, watch, out$ = typeof exports != 'undefined' && exports || this;
async = require('async');
browserify = require('browserify');
fs = require('fs');
path = require('path');
watchify = require('watchify');
path = path;
fileSystem = require("./fileSystem");
logging = require("./logging");
out$.sourceExtension = sourceExtension = "coffee";
out$.targetExtension = targetExtension = "js";
globalOptions = global.options;
out$.pathReloads = pathReloads = curry$(function(options, path){
  return path === globalOptions.tasks.watchBrowserify.targetPath;
});
out$.sourceFilePathMatches = sourceFilePathMatches = curry$(function(options, sourceFilePath){
  var resolvedSourceDirectoryPath, resolvedSourceFilePath, resolvedTargetPath;
  resolvedSourceDirectoryPath = path.resolve(options.sourceDirectory);
  resolvedSourceFilePath = path.resolve(sourceFilePath);
  resolvedTargetPath = path.resolve(options.targetPath);
  if (resolvedSourceFilePath === resolvedTargetPath) {
    return false;
  } else if (0 === resolvedSourceFilePath.indexOf(resolvedSourceDirectoryPath)) {
    return true;
  } else {
    return false;
  }
});
out$.compileAllFiles = compileAllFiles = function(options, cb){
  fs.exists(options.sourcePath, function(exists){
    if (!exists) {
      logging.taskInfo(options.taskName, "skipping `" + options.sourcePath + "` (Does not exist)");
      return cb();
    }
    fileSystem.ensureFileDirectory(options.targetPath, function(error){
      var b;
      if (error) {
        return cb(error);
      }
      b = browserify({
        cache: {},
        debug: true,
        fullPaths: true,
        packageCache: {}
      });
      b.transform("reactify");
      b.add(path.resolve(options.sourcePath));
      b.on("bundle", function(bundleStream){
        var writeStream;
        writeStream = fs.createWriteStream(options.targetPath);
        writeStream.on("error", function(error){
          cb(error);
        });
        writeStream.on("finish", function(){
          logging.taskInfo(options.taskName, "`" + options.sourcePath + "` => `" + options.targetPath + "`");
          cb();
        });
        return bundleStream.pipe(writeStream);
      });
      b.bundle();
    });
  });
};
out$.watch = watch = function(options, cb){
  var b, w;
  cb();
  b = browserify({
    cache: {},
    debug: true,
    fullPaths: true,
    packageCache: {}
  });
  b.transform("reactify");
  b.add(path.resolve(options.sourcePath));
  b.on("bundle", function(bundleStream){
    var data;
    data = "";
    bundleStream.on("data", function(d){
      data = data + "" + d.toString();
    });
    return bundleStream.on("end", function(){
      fs.writeFile(options.targetPath, data, function(e){
        if (e) {
          return error(e);
        }
        logging.taskInfo(options.taskName, "`" + options.sourcePath + "` => `" + options.targetPath + "`");
      });
    });
  });
  w = watchify(b);
  w.on("update", function(){
    b.bundle();
  });
  b.bundle();
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}