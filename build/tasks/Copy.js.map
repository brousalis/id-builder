{"version":3,"sources":["unknown"],"names":[],"mappings":";;;;;;;;;;;;;;;;sBAAc,QAAQ;;;;qBACD,OAAO;;8BAEJ,oBAAoB;;;;IAEtC,IAAI;YAAJ,IAAI;;WAAJ,IAAI;0BAAJ,IAAI;;+BAAJ,IAAI;;;eAAJ,IAAI;;;;;;WAY0B,4CAAC,IAAI,EAAE;AACvC,UAAI,MAAM,GAAG,IAAI,CAAC;;AAElB,0BAAE,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,UAAC,IAAI,EAAK;AAChC,YAAI,IAAI,CAAC,qBAAqB,IAAI,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;AAC3E,gBAAM,GAAG,KAAK,CAAC;SAChB;OACF,CAAC,CAAC;;AAEH,aAAO,MAAM,CAAC;KACf;;;WAEO,kBAAC,EAAE,EAAE;;;AACX,UAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,mBAAmB,EAAE,UAAC,CAAC,EAAE,KAAK,EAAK;AACpD,YAAI,CAAC,EAAE;AACL,iBAAO,EAAE,CAAC,CAAC,CAAC,CAAC;SACd;;AAED,YAAM,KAAK,GAAG,yBAAE,KAAK,CAAC,CACnB,MAAM,CAAC,MAAK,kCAAkC,CAAC,IAAI,OAAM,CAAC,CAC1D,GAAG,CAAC,UAAA,CAAC;iBAAI,CAAC,CAAC,QAAQ;SAAA,CAAC,CACpB,KAAK,EAAE,CAAC;;AAEX,UAAE,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;OACjB,CAAC,CAAC;KACJ;;;;;;WAIW,sBAAC,KAAK,EAAE,EAAE,EAAE;AACtB,QAAE,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;KACjB;;;WAEE,aAAC,EAAE,EAAE;;;AACN,UAAI,CAAC,QAAQ,CAAC,UAAC,CAAC,EAAE,KAAK,EAAK;AAC1B,YAAI,CAAC,EAAE;AACL,iBAAO,EAAE,CAAC,CAAC,CAAC,CAAC;SACd;;AAED,YAAM,WAAW,GAAG,SAAd,WAAW,CAAI,0BAA0B,EAAE,EAAE,EAAK;AACtD,cAAM,0BAA0B,GAAG,0BAA0B,CAAC,OAAO,CAAC,OAAK,mBAAmB,EAAE,OAAK,mBAAmB,CAAC,CAAC;;AAE1H,iBAAK,WAAW,CAAC,0BAA0B,EAAE,0BAA0B,EAAE,EAAE,CAAC,CAAC;SAC9E,CAAC;;AAEF,yBAAK,KAAK,EAAE,WAAW,EAAE,EAAE,CAAC,CAAC;OAC9B,CAAC,CAAC;KACJ;;;SA1Da,eAAG;;;AACf,aAAO,oBAAE,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,aAAa,EAAE,UAAC,CAAC,EAAE,CAAC,EAAK;AACpD,YAAI,CAAC,KAAK,OAAK,IAAI,EAAE;AACnB,iBAAO,CAAC,CAAC;SACV;OACF,CAAC,CAAC;KACJ;;;SAPG,IAAI;;;qBA8DK,IAAI","file":"unknown","sourcesContent":["import _ from 'lodash';\nimport { each } from 'async';\n\nimport CompileTask from '../lib/CompileTask';\n\nclass Copy extends CompileTask {\n  get otherTasks() {\n    return _.filter(this.builder.taskInstances, (v, k) => {\n      if (k !== this.name) {\n        return v;\n      }\n    });\n  }\n\n  // Check all other tasks for sourceFilePathMathches functions and\n  // only return true if no other matches, so don't copy files any\n  // other task is interested in.\n  doesntMatchOtherTaskSourceFilePath(node) {\n    let result = true;\n\n    _.each(this.otherTasks, (task) => {\n      if (task.sourceFilePathMatches && task.sourceFilePathMatches(node.fullPath)) {\n        result = false;\n      }\n    });\n\n    return result;\n  }\n\n  getPaths(cb) {\n    this.getFiles(this.sourceDirectoryPath, (e, nodes) => {\n      if (e) {\n        return cb(e);\n      }\n\n      const paths = _(nodes)\n        .filter(this.doesntMatchOtherTaskSourceFilePath.bind(this))\n        .map(v => v.fullPath)\n        .value();\n\n      cb(null, paths);\n    });\n  }\n\n  // Just return the chunk to perform a copy file CompileTask#compileFile.\n  // Explicitly defined to show the behaviour.\n  compileChunk(chunk, cb) {\n    cb(null, chunk);\n  }\n\n  run(cb) {\n    this.getPaths((e, paths) => {\n      if (e) {\n        return cb(e);\n      }\n\n      const iteratePath = (currentSourceDirectoryPath, cb) => {\n        const currentTargetDirectoryPath = currentSourceDirectoryPath.replace(this.sourceDirectoryPath, this.targetDirectoryPath);\n\n        this.compileFile(currentSourceDirectoryPath, currentTargetDirectoryPath, cb);\n      };\n\n      each(paths, iteratePath, cb);\n    });\n  }\n}\n\nexport default Copy;\n"]}