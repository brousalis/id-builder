{"version":3,"sources":["unknown"],"names":[],"mappings":";;;;;;;;;;;;;;;;oBAAwB,MAAM;;0BAEP,YAAY;;;;uBACf,SAAS;;;;kBACN,IAAI;;0BAEP,gBAAgB;;;;8BACZ,oBAAoB;;;;IAEtC,iBAAiB;YAAjB,iBAAiB;;AACV,WADP,iBAAiB,GACK;QAAd,OAAO,yDAAG,EAAE;;0BADpB,iBAAiB;;AAEnB,+BAFE,iBAAiB,6CAEb,OAAO,EAAE;;AAEf,QAAI,CAAC,cAAc,GAAG,OAAO,CAAC,cAAc,CAAC;AAC7C,QAAI,CAAC,cAAc,GAAG,OAAO,CAAC,cAAc,CAAC;GAC9C;;eANG,iBAAiB;;WAYF,+BAAG;AACpB,UAAM,CAAC,GAAG,6BAAW,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;;AAE3C,UAAM,WAAW,GAAG,OAAO,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC;;AAEpD,UAAM,cAAc,GAAG;AACrB,oBAAY,EAAE,IAAI;AAClB,cAAM,EAAE,IAAI;AACZ,mBAAW,EAAE,WAAW;OACzB,CAAC;;AAEF,OAAC,CAAC,SAAS,uBAAU,cAAc,CAAC,CAAC;;AAErC,aAAO,CAAC,CAAC;KACV;;;WAEW,sBAAC,KAAK,EAAE,EAAE,EAAE;AACtB,UAAM,MAAM,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;;AAE1C,YAAM,CAAC,GAAG,CAAC,mBAAQ,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;;AAEzC,YAAM,CAAC,EAAE,CAAC,QAAQ,EAAE,UAAA,YAAY,EAAI;AAClC,YAAI,IAAI,GAAG,EAAE,CAAC;;AAEd,oBAAY,CAAC,EAAE,CAAC,MAAM,EAAE,UAAA,CAAC,EAAI;AAC3B,cAAI,IAAI,CAAC,CAAC;SACX,CAAC,CAAC;;AAEH,oBAAY,CAAC,EAAE,CAAC,KAAK,EAAE,YAAM;AAC3B,YAAE,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;SAChB,CAAC,CAAC;OACJ,CAAC,CAAC;;AAEH,YAAM,CAAC,MAAM,EAAE,CAAC;KACjB;;;WAEU,qBAAC,cAAc,EAAwB,cAAc,EAAwB,EAAE,EAAE;UAAhF,cAAc,gBAAd,cAAc,GAAG,IAAI,CAAC,cAAc;;;;UAAE,cAAc,gBAAd,cAAc,GAAG,IAAI,CAAC,cAAc;;AACpF,sBAAO,cAAc,EAAE,UAAC,SAAS,EAAK;AACpC,YAAI,SAAS,EAAE;AACb,qCAnDF,iBAAiB,+CAmDG,cAAc,EAAE,cAAc,EAAE,EAAE,EAAE;SACvD,MAAM;AACL,kCAAQ,QAAQ,CAAC,MAAK,WAAW,CAAC,IAAI,gBAAc,cAAc,uBAAoB,CAAC;AACvF,YAAE,EAAE,CAAC;SACN;OACF,CAAC,CAAC;KACJ;;;WAEE,aAAC,EAAE,EAAE;AACN,UAAI,CAAC,WAAW,CAAC,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,cAAc,EAAE,EAAE,CAAC,CAAC;KAChE;;;SArDgC,eAAG;AAClC,aAAO,IAAI,MAAM,OAAK,IAAI,CAAC,cAAc,OAAI,CAAC;KAC/C;;;SAVG,iBAAiB;;;qBAgER,iBAAiB","file":"unknown","sourcesContent":["import { resolve } from 'path';\n\nimport browserify from 'browserify';\nimport jadeify from 'jadeify';\nimport { exists } from 'fs';\n\nimport logging from '../lib/logging';\nimport CompileTask from '../lib/CompileTask';\n\nclass BrowserifyCompile extends CompileTask {\n  constructor(options = {}) {\n    super(options);\n\n    this.sourceFilePath = options.sourceFilePath;\n    this.targetFilePath = options.targetFilePath;\n  }\n\n  get sourceFilePathMatchExpression() {\n    return new RegExp(`^${this.sourceFilePath}$`);\n  }\n\n  getBrowserifyBundle() {\n    const b = browserify(this.options.options);\n\n    const jadeRuntime = require.resolve('jade/runtime');\n\n    const jadeifyOptions = {\n      compileDebug: true,\n      pretty: true,\n      runtimePath: jadeRuntime\n    };\n\n    b.transform(jadeify, jadeifyOptions);\n\n    return b;\n  }\n\n  compileChunk(chunk, cb) {\n    const bundle = this.getBrowserifyBundle();\n\n    bundle.add(resolve(this.sourceFilePath));\n\n    bundle.on('bundle', bundleStream => {\n      let data = '';\n\n      bundleStream.on('data', d => {\n        data += d;\n      });\n\n      bundleStream.on('end', () => {\n        cb(null, data);\n      });\n    });\n\n    bundle.bundle();\n  }\n\n  compileFile(sourceFilePath = this.sourceFilePath, targetFilePath = this.targetFilePath, cb) {\n    exists(sourceFilePath, (doesExist) => {\n      if (doesExist) {\n        super.compileFile(sourceFilePath, targetFilePath, cb);\n      } else {\n        logging.taskInfo(this.constructor.name, `skipping ${sourceFilePath} (Does not exist)`);\n        cb();\n      }\n    });\n  }\n\n  run(cb) {\n    this.compileFile(this.sourceFilePath, this.targetFilePath, cb);\n  }\n}\n\nexport default BrowserifyCompile;\n\n/*\nfunction watch(options, cb) {\n  log.debug('lib/browserify.watch');\n\n  exists(options.sourceFilePath, exists => {\n    if (!exists) {\n      logging.taskInfo(options.taskName, `skipping ${options.sourceFilePath} (Does not exist)`);\n      return cb();\n    }\n\n    fileSystem.ensureFileDirectory(options.targetFilePath, e => {\n      if (e) {\n        return cb(e);\n      }\n\n      const b = getBrowserifyBundle(options);\n\n      b.add(resolve(options.sourceFilePath));\n\n      b.on('bundle', bundleStream => {\n        let data = '';\n\n        bundleStream.on('data', d => {\n          data += d;\n        });\n\n        bundleStream.on('end', () => {\n          writeFile(options.targetFilePath, data, e => {\n            if (e) {\n              return cb(e);\n            }\n\n            logging.taskInfo(options.taskName, `${options.sourceFilePath} => ${options.targetFilePath}`);\n          });\n        });\n      });\n\n      const w = watchify(b);\n\n      w.on('update', () => {\n        b.bundle();\n      });\n\n      b.bundle();\n    });\n  });\n}\n*/\n"]}